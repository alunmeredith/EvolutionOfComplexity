{
    "contents" : "# packages\nif (!require(data.table)){\n  install.packages(\"data.table\")\n  library(data.table)\n}\nif (!require(ggplot2)){\n  install.packages(\"ggplot2\")\n  library(ggplot2)\n}\n\ntest1 <- 0\ntest2 <- 0\ntest3 <- 0\n#------- STEP 2 GROUP FORMATION -------\ngroupFormation <- function() {\n  \n  # Total individuals with each group allele. \n  dispersedPop[, Sum := rowSums(floor(.SD)), .SDcols = 2:(levels+1)]\n  smallGroups <- floor(dispersedPop[group == \"small\", Sum] \n                       / groupSizeSmall)\n  largeGroups <- floor(dispersedPop[group == \"large\", Sum] \n                       / groupSizeLarge)\n  if (length(largeGroups) == 0) largeGroups = 0L\n  if (length(smallGroups) == 0) smallGroups = 0L\n  \n  \n  # Add each small individual to a pool and create a sample queue\n  poolSmall <- vector()\n  invisible(sapply(1:levels, function(x) {\n    block <- rep(as.integer(x), \n                 dispersedPop[1, get(paste0(\"level\", x))])\n    poolSmall <<- c(poolSmall, block)\n  }))\n  poolSmall <- sample(poolSmall, length(poolSmall), replace = F)\n  \n  # Populate groups from the sample\n  for (i in 1:(smallGroups - 1)) {\n    startIndex <- groupSizeSmall * i\n    endIndex <- groupSizeSmall * (i+1) - 1\n    popRow <- as.numeric(sapply(1:levels, function(x) {\n      sum(poolSmall[startIndex:endIndex] == x)\n    }))\n    population[i, group := .(\"small\")]\n    invisible(sapply(1:levels, function(x) {\n      population[i, x + 2 := popRow[x]]\n    }))\n  }\n  \n  if (length(largeGroups) == 0) largeGroups = 0L\n  if (largeGroups > 0) {\n    # Repeat for large groups\n    poolLarge <- vector()\n    invisible(sapply(1:levels, function(x) {\n      block <- rep(as.integer(x),\n                   dispersedPop[1, get(paste0(\"level\", x))])\n      poolLarge <<- c(poolLarge, block)\n    }))\n    poolLarge <- sample(poolLarge, length(poolLarge), replace = F)\n    \n    # Populate groups from the sample\n    for (i in 1:(largeGroups - 1)) {\n      startIndex <- groupSizeLarge * i\n      endIndex <- groupSizeLarge * (i+1) - 1\n      popRow <- as.numeric(sapply(1:levels, function(x) {\n        sum(poolLarge[startIndex:endIndex] == x)\n      }))\n      population[i + smallGroups + 1, group := .(\"large\")]\n      invisible(sapply(1:levels, function(x) {\n        population[i + smallGroups + 1, x + 2 := popRow[x]]\n      }))\n    }\n  }\n}\n\n#------- STEP 3 Repdroduction ---------\n\n\nreproduction <- function() {\n  \n  invisible(sapply(1:maxGroups, function(x) {\n    \n    n <- population[x, .SD, .SDcols = 3:(levels+2)]\n    \n    # R is based on group size\n    ifelse(population[x, (group == \"large\") & !is.na(group)],\n           R <- Rlarge,\n           R <- Rsmall\n    ) \n    \n    # Calculate share of the resource. \n    ngc <- n * G * C\n    NGC <- sum(ngc)\n    r <- R * ngc / NGC \n    \n    # Calculate new population sizes\n    nNext <- n + r/C - K*n\n    \n    # Set new population sizes\n    invisible(sapply(1:levels, function (y) {\n      population[x, y + 2 :=  as.numeric(nNext[[y]])]\n    }))\n  }))\n}\n\nbuildMigrantPool <- function() {\n#------- STEP 4 MIGRANT POOL FORMATION ---------\n  unformatted <- population[, colSums(.SD, na.rm = T), \n                            .SD = 1:levels+2, by = .(group)]\n  vars <- names(dispersedPop)[2:(levels+1)]\n  set(dispersedPop, 1L, vars, \n      as.list(unformatted[ group == \"small\"]$V1))\n  if(nrow(unformatted[group==\"large\"])>0 ) {\n    set(dispersedPop, 2L, vars, \n        as.list(unformatted[ group == \"large\"]$V1))\n  }\n  \n  # STEP 5 MAINTAINING GLOBAL CARRYING CAPACITY \n  dispersedPop[, Sum := rowSums(.SD), .SDcols = 2:(levels+1)]\n  scalingFactor <- sum(dispersedPop$Sum) / N\n  \n  set(dispersedPop, 1L, vars,\n      (dispersedPop[1L, .SD, .SDcols = (vars)] / scalingFactor))\n  set(dispersedPop, 2L, vars,\n      (dispersedPop[ 2L, .SD, .SDcols = (vars)] / scalingFactor))  \n  \n  dispersedPop[, Sum := rowSums(.SD), .SDcols = 2:(levels+1)]\n  \n  return(dispersedPop)\n}\n\n######## Mutation #############\nmutate <- function(rate) {\n  \n  numberOfGroups <- floor(dispersedPop[group == \"small\", Sum] \n                          / groupSizeSmall) +\n    floor(dispersedPop[group == \"large\", Sum] / groupSizeLarge)\n  \n  invisible(sapply(1:(numberOfGroups-1), function(i) {\n    row <- population[i, .SD, .SDcols = 3:(levels+2)]\n    if (sum(is.na(row) > 0)) return(row)\n    # Calculate mutations going up\n    end <- TRUE\n    up <- sapply(row, function(x){\n      if(x < 0) return(0)\n      rand <- sample(ceiling(2/rate), floor(x), replace = TRUE)\n      ifelse(end == TRUE, {\n             mutateUp <- sum(rand == 1 | rand == 2)\n             end <<- FALSE },\n             mutateUp <- sum(rand == 1))\n      return(mutateUp)\n    })\n    up[levels] <- 0\n    \n    # Calculate mutations going up\n    end <- TRUE\n    down <- rev(sapply(rev(row), function(x){\n      if (x < 0) { return(0)}\n      rand <- sample(ceiling(2/rate), floor(x), replace = TRUE)\n      ifelse(end == TRUE,\n             mutateDown <- sum(rand == 1 | rand == 2),\n             mutateDown <- sum(rand == 1))\n      return(mutateDown)\n    }))\n    down[1] <- 0 \n\n    movement <- c(0,up[1:(levels-1)]) + \n      c(down[2:(levels)],0) - up - down \n    newRow <- movement + row\n    \n    vars <- names(population)[3:(levels+2)]\n    set(population, as.integer(i), vars, newRow)\n  }))\n}",
    "created" : 1451999362217.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "160247111",
    "id" : "256EBA0",
    "lastKnownWriteTime" : 1451999430,
    "path" : "~/Southampton/EvolutionOfComplexity/CW2/extensionHeader.R",
    "project_path" : "extensionHeader.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}