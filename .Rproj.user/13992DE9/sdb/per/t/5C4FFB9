{
    "contents" : "# Assignment 1 from the evolution of complexity course (not assessed)\n# http://sussed.soton.ac.uk/tag.895ea393565329bb.render.userLayoutRootNode.uP?uP_root=root&uP_sparam=activeTab&activeTab=u11l1s168&uP_tparam=frm&frm=frame\n\n# Fitness function = number of matching characters\n# Mutation rate = 1/L (L = # characters in target string)\n# Selection process = Tournament size 2\n\ntarget <- function(phrase)\n{\n  targetString <<- phrase\n  targetInt <<- as.integer(charToRaw(targetString))\n  L <<- nchar(targetString)\n}\n\n# INITIAL()\n# Creates N random individuals (columns), saved globally\ninitial <- function(N=500) {\n  population <<- sapply(1:N,  function(x) floor(runif(L,32,127)))\n}\n\n# FITNESS()\n# Compares individual to target and evaluates number of matching characters\nfitness <- function(population) {\n  mpopulation <- as.matrix(population)\n  apply(mpopulation, 2, function(x) sum((x - targetInt) == 0))\n}\n\n# MUTATION()\n# Function that mutates randomly an average of 1 character\n# Mutation is applied to an individual\nmutation <- function(population, decayRate=1/L) {\n  mpopulation <- as.matrix(population)\n  apply(mpopulation, 2, function(individual)\n    sapply(individual, function(x)\n    ifelse(runif(1,0,1) < decayRate, x <- floor(runif(1,32,127)), x <- x)))\n}\n\n# INDIVIDUAL()\n# Function to randomly pick n individuals from the population\n# Returns a list of two elements, the individual and their index within the population\nindividual <- function(population, n=1) {\n  x <- floor(runif(n, 1, ncol(population)+1)) # r uses 1 as its base index\n  return(list(population[,x], x))\n}\n\n### HILL CLIMBER\nhillClimber <- function(popSize=500, decayRate=1/L, phrase=\"Methinks it is like a weasel\")\n{\n  target(phrase)\n  initial(1)\n  itterationsHC = 0\n  while( fitness(population) != L) # Loops until phrase is found\n  {\n    new <- mutation(population, decayRate) # Average of 1 mutation per cycle\n    if (fitness(new) > fitness(population)) {\n      population <<- new\n    }\n    itterationsHC = itterationsHC + 1\n    if (itterationsHC %% 1000*popSize == 0) if(exists(\"j\")) { # Saves fitness every 1000 cycles\n      fit[itterationsHC/1000, j] <<- max(fitness(population))\n    }\n    if (itterationsHC > 100000) return(fitness(population)) # Break clause if too many cycles\n  }\n  print(j)\n  return(itterationsHC)\n}\n\n### Genetic Algorithm without crossover\n# Note that crossover algorithm only mutates one individual per itteration\n# Hillclimber mutates P (500) times per itteration\nnoCrossover <- function(popSize=500, decayRate=1/L, phrase=\"Methinks it is like a weasel\")\n{\n  target(phrase)\n  initial(popSize)\n  itterationsGA = 0\n  while( max(fitness(population)) != L) # Loops until phrase is found\n  {\n    # Host a tournament to select individual to mutate\n    parents <- individual(population, 2)\n    child <- mutation(\n      parents[[1]][,which.max(fitness(parents[[1]]))], decayRate)\n  \n    # Host a tournament to select an individual to be replaced\n    tournament <- individual(population, 2)\n    n <- tournament[[2]][which.min(fitness(tournament[[1]]))]\n    population[,n] <- child\n    \n    itterationsGA = itterationsGA + 1\n    if (itterationsGA %% 1000*popSize == 0) if(exists(\"j\")) {  # Saves fitness every 1000 cycles\n      fit[itterationsGA/1000, j] <<- max(fitness(population))\n    }\n    if (itterationsGA > 100000) return(itterationsGA)  # Breaks after too many cycles\n  }\n  return(itterationsGA)\n}\n\n### Genetic Algorithm with crossover\n# Note that crossover algorithm only mutates one individual per itteration\n# Hillclimber mutates 500 individuals per itteration\ncrossover <- function(popSize=500, decayRate=1/L, phrase=\"Methinks it is like a weasel\") \n{\n  target(phrase)\n  initial(popSize)\n  itterationsGAC = 0\n  while( max(fitness(population)) != L) # Loops until phrase is found\n  {\n    # Host a tournament to select individual to mutate\n    parentsTourn <- individual(population, 4)\n    parent <- matrix(nrow = L, ncol = 2)\n    parent[,1] <- parentsTourn[[1]][,which.max(fitness(parentsTourn[[1]][,1:2]))]\n    parent[,2] <- parentsTourn[[1]][,which.max(fitness(parentsTourn[[1]][,3:4]))+2]\n    \n    # Crossover child and mutate\n    crossover <- sample(c(1,2), L, replace = T)\n    child = 0\n    for (i in 1:L) child[i] = parent[i, crossover[i]]\n    \n    # Host a tournament to select an individual to be replaced\n    tournament <- individual(population, 2)\n    n <- tournament[[2]][which.min(fitness(tournament[[1]]))]\n    population[,n] <- mutation(child, decayRate)\n    \n    itterationsGAC = itterationsGAC + 1\n    if (itterationsGAC %% 1000*popSize == 0) if(exists(\"j\")) {  # Saves fitness every 1000 cycles\n      fit[itterationsGAC/1000, j] <<- max(fitness(population))\n    if (itterationsGAC > 100000) return(itterationsGAC) # Breaks after too many cycles\n    }\n  }\n  return(itterationsGAC)\n}\n\n",
    "created" : 1445295732111.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4194584447",
    "id" : "5C4FFB9",
    "lastKnownWriteTime" : 1445103440,
    "path" : "~/Work/DataScience/Southampton/EvolutionofComplexity/Hello Evolutionary Algorithm World.R",
    "project_path" : "Hello Evolutionary Algorithm World.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}